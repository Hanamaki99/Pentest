# 文件上传

> 单独拿出来 内容不多 变化没有SQL注入那么多 配合别的漏洞发挥更大的价值 了解起来比较快
>
> 配合的漏洞会在后面遇到了在说



目的明确：GETSHELL拿flag

出现上传点，可能需要利用或者配合上传漏洞辅助拿Flag

必然会在上传的地方做一些防护

常见的上传安全检测方式的绕过



## 客户端校验--JavaScript校验



本地->传输->远端服务器



JS在本地浏览器运行，从某种程度上来说，可以控制（不运行）



### 绕过方法



- 抓包改包
- 禁用JS



### 本地校验 远程检验方法检测



点击上传 浏览器抓包



### 禁用JS



Chrome F12 F1



### 抓包改包



上传phpinfo.png改成phpinfo.php



### 练习题



http://106.12.37.37:10001/





## 服务端校验--Content-type校验



- 扩展名：gif	MIME类型：image/gif
- 扩展名：png MIME类型：image/png
- 扩展名：jpg MIME类型：image/jpeg
- 扩展名：js MIME类型：text/javascript
- 扩展名：htm MIME类型：text/html
- 扩展名：html MIME类型：text/html
- ……



### 绕过方法



- 抓包改content-type字段
- 改文件名后上传抓包后再改回文件名
- 上传正常文件改文件内容
- 反正最终目的就是一个content-type是正确的就可以



## 服务端校验--后缀名黑名单校验



- 考虑不周全
- 获取的文件名不是实际的文件名



### 绕过方法



- 大小写绕过，例如Php、PhP

- 利用黑名单中没有的，但是又能够被解析的后缀名，例如php、php3、php4、php5、php7、pht、phtml、phps

- 使用00截断

  基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候

- 超长文件名截断上传（windows 258byte | linux 4096byte）



### 练习题



http://teamxlc.sinaapp.com/web5/21232f297a57a5a743894a0e4a801fc3/index.html



#### 截断的核心



在与chr(0)这个字，char(0)表示的ascii字符是null，当程序输出包含chr(0)变量时，chr(0)后面的数据会被截断，后面的数据直接忽略，导致漏洞产生

pathinfo



## 服务端校验--白名单



> 只允许不能解析的文件上传，或者只允许业务需要的文件类型上传



例如头像

jpg、png、高级一点gif动一下



### 配合Apache的解析漏洞



.Apache的解析漏洞主要特性为Apache是从后面开始检查后缀，按最后一个合法后缀

> 太过智能化带来一些安全问题，Nginx和IIS都存在，需要配合中间件解析漏洞



### 配合其他漏洞（后面内容讲）





### 练习题



[http://106.12.37.37:10004](http://106.12.37.37:10004/)



## 服务端校验--内容头校验



### getimagesize函数



![](/home/dawnshaw/Pictures/Screenshot from 2019-08-06 00-37-25.png)



传入文件名验证，baidu.gif 1.php

```php
var dump(getimagesize('/var/www.html/img/1.php'))
```





### 文件头



下载一张jpg文件 xxd 1.jpg

再下载一张jpg文件 xxd 2.jpg

需要加入16进制的内容，可以加入一些可以显示的



### 绕过方法



在恶意脚本前加上允许上传文件的头标识

GIF89a



## 竞争上传



### 情景

文件上传后，检测是否合法，不合法就删除



### 注意



意味着文件存在于服务器上过，只是存在的时间很短

所以理论上还是能够访问到的

































































